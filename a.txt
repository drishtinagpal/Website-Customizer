import { useState } from "react";
import axios from "axios";

function App() {
  const [webpageLink, setWebpageLink] = useState("");
  const [userCommand, setUserCommand] = useState("");
  const [response, setResponse] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError("");
    
    try {
      const res = await axios.post("http://localhost:5000/api/process", {
        webpageLink,
        userCommand,
      });

      setResponse(res.data);
    } catch (err) {
      setError("Failed to process request. Please try again.");
      console.error(err);
    }
    
    setLoading(false);
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-100 p-6">
      <h1 className="text-2xl font-bold mb-4">AI Website Customizer</h1>
      
      <form onSubmit={handleSubmit} className="bg-white shadow-md p-6 rounded-lg w-full max-w-md">
        <label className="block mb-2 font-semibold">Website URL:</label>
        <input
          type="text"
          value={webpageLink}
          onChange={(e) => setWebpageLink(e.target.value)}
          placeholder="Enter website URL"
          className="w-full p-2 border rounded-md mb-4"
          required
        />

        <label className="block mb-2 font-semibold">Modification Request:</label>
        <textarea
          value={userCommand}
          onChange={(e) => setUserCommand(e.target.value)}
          placeholder="Describe how you want to modify the website..."
          className="w-full p-2 border rounded-md mb-4"
          rows="4"
          required
        />

        <button
          type="submit"
          className="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600"
          disabled={loading}
        >
          {loading ? "Processing..." : "Submit"}
        </button>
      </form>

      {error && <p className="text-red-500 mt-4">{error}</p>}

      {response && (
        <div className="mt-6 bg-gray-200 p-4 rounded-lg w-full max-w-lg">
          <h2 className="font-semibold mb-2">Response:</h2>
          <pre className="text-sm break-all">{JSON.stringify(response, null, 2)}</pre>
        </div>
      )}
    </div>
  );
}

export default App;














































const express = require("express");
const cors = require("cors");
const puppeteer = require("puppeteer");
const cheerio = require("cheerio");
const axios = require("axios");

require("dotenv").config();
const { GoogleGenerativeAI } = require("@google/generative-ai");

const app = express();
app.use(express.json());
app.use(cors());

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);


// Function to get token count using Gemini's tokenizer
const getTokenCount = async (text) => {
  try {
    if (!text) return 0; // Handle empty input

    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    const response = await model.countTokens({ contents: [{ parts: [{ text }] }] });

    return response.totalTokens || 0;
  } catch (error) {
    console.error("Error getting token count:", error);
    return 0;
  }
};

// Function to fetch webpage and extract all required data
const fetchWebpageData = async (url) => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto(url, { waitUntil: "domcontentloaded" });

  // Get the full HTML content
  const html = await page.content();
  await browser.close();

  // Load HTML into Cheerio
  const $ = cheerio.load(html);

  // Extract inline CSS (inside <style> tags)
  let inlineCSS = [];
  $("style").each((_, element) => {
    inlineCSS.push($(element).html());
  });

  // Extract inline JavaScript (inside <script> tags without src attribute)
  let inlineJS = [];
  $("script:not([src])").each((_, element) => {
    inlineJS.push($(element).html());
  });

  // Extract external CSS links
  let externalCSSLinks = [];
  $("link[rel='stylesheet']").each((_, element) => {
    externalCSSLinks.push($(element).attr("href"));
  });

  // Extract external JS links
  let externalJSLinks = [];
  $("script[src]").each((_, element) => {
    externalJSLinks.push($(element).attr("src"));
  });

  // Function to fetch external CSS & JS files
  const fetchExternalFiles = async (links) => {
    let files = {};
    for (let link of links) {
      try {
        if (link.startsWith("//")) link = "https:" + link; // Handle protocol-relative URLs
        if (!link.startsWith("http")) link = new URL(link, url).href; // Convert relative to absolute URL

        const response = await axios.get(link);
        files[link] = response.data;
      } catch (error) {
        console.error("Failed to fetch:", link);
      }
    }
    return files;
  };

  // Fetch external CSS & JS content
  const externalCSS = await fetchExternalFiles(externalCSSLinks);
  const externalJS = await fetchExternalFiles(externalJSLinks);

  // Compute token counts for each part
  const htmlTokenCount = await getTokenCount(html);
  const inlineCSSTokenCount = await getTokenCount(inlineCSS.join("\n"));
  const inlineJSTokenCount = await getTokenCount(inlineJS.join("\n"));
  const externalCSSTokenCount = await getTokenCount(Object.values(externalCSS).join("\n"));
  const externalJSTokenCount = await getTokenCount(Object.values(externalJS).join("\n"));

  console.log("Token Counts:");
  console.log("Full HTML:", htmlTokenCount);
  console.log("Inline CSS:", inlineCSSTokenCount);
  console.log("Inline JS:", inlineJSTokenCount);
  console.log("External CSS:", externalCSSTokenCount);
  console.log("External JS:", externalJSTokenCount);

  return {
    html,         // Full HTML of the webpage
    inlineCSS,    // Inline CSS inside <style> tags
    inlineJS,     // Inline JavaScript inside <script> tags
    externalCSS,  // External CSS file content
    externalJS,   // External JavaScript file content
    tokenCounts: {
      html: htmlTokenCount,
      inlineCSS: inlineCSSTokenCount,
      inlineJS: inlineJSTokenCount,
      externalCSS: externalCSSTokenCount,
      externalJS: externalJSTokenCount,
    },
  };
};



const TOKEN_LIMIT_PER_CHUNK = 400000; // Define token limit per chunk

const checkModificationNeeded = async (type, content, userCommand) => {
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

    // If content is an object, convert it to a string
    let contentStr = typeof content === "object" ? JSON.stringify(content) : content;

    // Get token count for the given content
    const tokenCount = await getTokenCount(contentStr);

    // If token count exceeds the limit, split into chunks
    if (tokenCount > TOKEN_LIMIT_PER_CHUNK) {
      console.log(`${type} exceeds token limit. Splitting into chunks...`);

      // Calculate number of chunks
      let numChunks = Math.ceil(tokenCount / TOKEN_LIMIT_PER_CHUNK);
      console.log(`numChunks: ${numChunks}`);

      // Calculate chunk size
      let chunkSize = Math.ceil(tokenCount / numChunks);
      console.log(`chunkSize: ${chunkSize}`);

      // Split content into chunks
      let contentChunks = await splitIntoChunks(contentStr, numChunks,tokenCount);
      

      let modificationResults = [];

      // Iterate exactly numChunks times
      for (let i = 0; i < numChunks; i++) {
        let chunk = contentChunks[i] ;//|| ""; // Ensure there's a chunk to process

        const prompt = `
          You are an AI that identifies if a webpage section needs modification based on user instructions.

          Type of content: ${type}
          Content:
          ${chunk}

          The user provided this modification request:
          "${userCommand}"

          If the modification request requires changes in this section, return true, otherwise return false.
        `;

        const result = await model.generateContent({
          contents: [{ role: "user", parts: [{ text: prompt }] }],
        });

        const responseText = await result.response.text(); // Extract response correctly
        let isModified = responseText.toLowerCase().includes("true");

        modificationResults.push(`Chunk ${i + 1}: ${isModified ? "true" : "false"}`);
      }

      // Display all chunk results
      console.log(`${type}: \n${modificationResults.join("\n")}`);

      return modificationResults;
    } else {
      // If token count is within limit, process normally
      const prompt = `
        You are an AI that identifies if a webpage section needs modification based on user instructions.

        Type of content: ${type}
        Content:
        ${contentStr}

        The user provided this modification request:
        "${userCommand}"

        If the modification request requires changes in this section, return true, otherwise return false.
      `;

      const result = await model.generateContent({
        contents: [{ role: "user", parts: [{ text: prompt }] }],
      });

      const responseText = await result.response.text(); // Extract response correctly
      let isModified = responseText.toLowerCase().includes("true");

      console.log(`${type}: ${isModified}`);
      return isModified;
    }
  } catch (error) {
    console.error(`Error checking modification for ${type}:`, error);
    return [];
  }
};

// Helper function to split content into `numChunks`
const splitIntoChunks = async (text, numChunks,tokenCount) => {
  let words = text.split(" ");
  let chunkSize = Math.ceil(tokenCount / numChunks);
  console.log(`chunk size: ${chunkSize}`);
  console.log(`type of text: ${typeof(text)}`);
  let chunks = [];
  for (let i = 0; i < numChunks; i++) {
    let start = i * chunkSize;
    let end = start + chunkSize;
    chunks.push(text.slice(start, end));

    // Await the token count before logging
    let per_chunk_size = await getTokenCount(Object.values(chunks[i]).join("\n"));
    console.log(`Each chunk size: ${per_chunk_size}`);
  }
  
  return chunks;
};








// API Route: Process user request
app.post("/api/process", async (req, res) => {
  const { webpageLink, userCommand } = req.body;

  if (!webpageLink || !userCommand) {
    return res.status(400).json({ error: "Missing required parameters." });
  }

  try {
    const webpageData = await fetchWebpageData(webpageLink);

    // Check each portion separately
    const results = {
      html: await checkModificationNeeded("HTML", webpageData.html, userCommand),
      inlineCSS: await checkModificationNeeded("Inline CSS", webpageData.inlineCSS.join("\n"), userCommand),
      inlineJS: await checkModificationNeeded("Inline JS", webpageData.inlineJS.join("\n"), userCommand),

      externalCSS: await checkModificationNeeded("External CSS", Object.values(webpageData.externalCSS).join("\n"), userCommand),
      externalJS: await checkModificationNeeded("External JS", Object.values(webpageData.externalJS).join("\n"), userCommand)
    };

    res.json({ success: true, modificationsNeeded: results });
  } catch (error) {
    console.error("Error processing request:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});




// Start Server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));





